<!DOCTYPE html>
<html>

<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>README</title>


<style type="text/css">
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body > *:first-child {
  margin-top: 0 !important; }
body > *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 28px;
  color: black; }

h2 {
  font-size: 24px;
  border-bottom: 1px solid #cccccc;
  color: black; }

h3 {
  font-size: 18px; }

h4 {
  font-size: 16px; }

h5 {
  font-size: 14px; }

h6 {
  color: #777777;
  font-size: 14px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
  background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
  border: 0 none;
  color: #cccccc;
  height: 4px;
  padding: 0;
}

body > h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body > h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }
li {
  margin: 0; }
ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt > :first-child {
      margin-top: 0; }
    dl dt > :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd > :first-child {
      margin-top: 0; }
    dl dd > :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote > :first-child {
    margin-top: 0; }
  blockquote > :last-child {
    margin-bottom: 0; }

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%; }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; }

sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}

kbd {
  display: inline-block;
  padding: 3px 5px;
  font-size: 11px;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb
}

* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:0 auto;
    }
}
@media print {
	table, pre {
		page-break-inside: avoid;
	}
	pre {
		word-wrap: break-word;
	}
}
</style>


</head>

<body>

<p><head>
<link rel="stylesheet" type="text/css" href="resumen.css">
</head></p>

<h1 id="toc_0">Grammatical Framework</h1>

<p><a href="http://www.grammaticalframework.org/">Grammatical Framework</a> (GF) es un lenguaje de programación diseñado para escribir gramáticas multilingües.
Inspirado por la construcción de compiladores se basa en la definición de una sintaxis abstracta y mapeos entre la sintaxis abstracta y lenguajes concretos.
Creado por <a href="http://www.cse.chalmers.se/%7Eaarne/">Aarne Ranta</a>, Profesor de Ciencias de la Computación en la Universidad de Gotemburgo.
GF fue creado en 1998 en <a href="http://www.xrce.xerox.com/">Xerox Research Centre Europe</a>, Grenoble, en el proyecto Multilingual Document Authoring.</p>

<h3 id="toc_1">GF es:</h3>

<ul>
<li>Un lenguaje de propósito específico en gramáticas, como <a href="http://dinosaur.compilertools.net/yacc/">YACC</a>, <a href="https://www.gnu.org/software/bison/">Bison</a>, <a href="https://www.haskell.org/happy/">Happy</a>, <a href="http://bnfc.digitalgrammars.com/">BNFC</a>.</li>
<li>Un lenguaje de programación funcional, como <a href="https://www.haskell.org/">Haskell</a>, <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a>, <a href="http://ocaml.org/">OCaml</a>, <a href="http://www.smlnj.org/">SML</a>, <a href="http://schemers.org/">Scheme</a>.</li>
<li>Una plataforma de desarrollo para gramáticas de lenguaje natural, como <a href="http://moin.delph-in.net/LkbTop">LKB</a>, <a href="http://www2.parc.com/isl/groups/nltt/xle/">XLE</a>, <a href="http://www.issco.unige.ch/en/research/projects/regulus/news.shtml">Regulus</a>.</li>
<li>Un formalismo de gramáticas categoriales, como <a href="http://calligramme.loria.fr/acg/">ACG</a>, <a href="http://openccg.sourceforge.net/">CCG</a>.</li>
<li>Un framework lógico, como <a href="http://wiki.portal.chalmers.se/agda/pmwiki.php">Agda</a>, <a href="https://coq.inria.fr/">Coq</a>, <a href="http://www.cl.cam.ac.uk/research/hvg/Isabelle/">Isabelle</a>, equipado con sintaxis concreta en adición a lógica.</li>
<li>Una plataforma para traducción automática, como <a href="http://www.statmt.org/moses/">Moses</a>, <a href="https://es.wikipedia.org/wiki/Apertium">Apertium</a>.</li>
</ul>

<h3 id="toc_2">Licencias y disponibilidad</h3>

<p>GF es de código abierto, con licencia <a href="http://www.grammaticalframework.org/LICENSE">GPL</a> para el programa y <a href="http://www.grammaticalframework.org/LICENSE">LGPL</a>, <a href="http://www.grammaticalframework.org/LICENSE">BSD</a> para las liberías. 
Está disponible en:</p>

<ul>
<li>Linux</li>
<li>Mac OS X</li>
<li>Windows</li>
<li>Android (via Java)</li>
<li>Javascript (via compilación)</li>
</ul>

<h2 id="toc_3">¿Por qué gramáticas?</h2>

<h3 id="toc_4">Tradición vs. GF</h3>

<p>Tradicionalmente las gramáticas de lenguaje natural han sido vistas únicamente como parte de la teoría lingüística. 
GF sugiere un punto de vista más computacional, diferente al de las gramáticas tradicionales, el cual puede ser visto como &quot;compilación de lenguaje natural&quot;, basado en los fundamentos de construcción de compiladores, teniendo en cuenta que los compiladores han sido un caso exitoso del uso de gramáticas.</p>

<h3 id="toc_5">Precisión vs. robustez</h3>

<p>La implementación de gramáticas ofrece una gran precisión en la traducción de lenguajes, teniendo como desventaja una pérdida en la cantidad de frases aceptadas. 
Los métodos estadísticos poseen, al contrario, mayor robustez pero con dificultades de conseguir la misma precisión que las gramáticas.
Tomando como trabajo la traducción de lenguaje natural a un lenguaje formal, como el de la lógica de primer orden y pensando además en una posible utilización de la herramienta en un ámbito educativo, parece oportuno priorizar la precisión de la traducción antes que la cobertura.
Para trabajar con la herramienta y lidiar con el hecho de no cubrir algunas oraciones de lenguaje natural, la implementación contará con algun método de completado de frases, al estilo tab-completion, para la construcción guiada de frases correctas para la gramática. 
Como trabajo futuro podría ser interesante construir un sistema híbrido, con el objetivo de unir la gramática definida con herramientas estadísticas y lograr así un sistema más robusto.</p>

<h3 id="toc_6">GF como un lenguaje de programación</h3>

<p>Las gramáticas en GF son vistas como programas declarativos capaces de:</p>

<ul>
<li>parsear</li>
<li>generar</li>
<li>traducir</li>
</ul>

<p>GF es un lenguaje de programación avanzado y de alto nivel, permitiendo:</p>

<ul>
<li>Programación funcional: Una forma abstracta y compacta de escribir gramáticas.</li>
<li>Funciones de alto orden.</li>
<li>Tipos dependientes.</li>
<li>Type-checking estático: Gramáticas compiladas.</li>
<li>Pattern matching sobre constructores de datos.</li>
<li>Sistema de modulos con herencia y modulos parametrizados.</li>
</ul>

<h3 id="toc_7">Resource Grammar Library (RGL)</h3>

<p>GF cuenta además con una librería llamada <a href="http://www.grammaticalframework.org/lib/doc/synopsis.html">RGL</a> (Resource Grammar Library) que provee inflexiones morfológicas y reglas sintácticas de varios lenguajes (actualmente 32), incluído el español.</p>

<p>La RGL maneja de manera inteligente la morfología de la mayoría de estos lenguajes.
Un caso donde puede aprovecharse esto es que la librería defina automáticamente las variaciones de una palabra analizando la morfología de la misma.</p>

<p>Por ejemplo, en inglés un verbo regular como talk, genera automáticamente sus diferentes inflexiones:</p>

<div><pre><code class="language-none">mkV : Str -&gt; V
mkV &quot;talk&quot; =&gt; talk, talks, talked, talked, talking</code></pre></div>

<p>Esto permite la construcción de un lexicón solo dando una única forma de cada palabra.</p>

<h3 id="toc_8">Diagrama de funcionamento de GF</h3>

<p>El funcionamento de GF está inspirado fuertemente por el funcionamento de compiladores. </p>

<p>El modelo puede resumirse como un &quot;Multi-source Multi-target compiler&quot;.</p>

<p><img src="Images/normal_compiler.png" alt="compiler"></p>

<h2 id="toc_9">Sintaxis abstracta y concreta</h2>

<h3 id="toc_10">Sintaxis abstracta</h3>

<p>La sintaxis abstracta formaliza la semántica esencial que es común a todos los lenguajes.
Se construye mediante una gramática abstracta, definiendo los posibles árboles de sintaxis abstractos (AST).</p>

<p>En la sintaxis abstracta se definen:</p>

<ul>
<li><p>Categorías (cat): Que serán los tipos de los AST.</p></li>
<li><p>Funciones (fun) sobre las categorías definidas. Estas funciones son las que definen los AST.</p></li>
</ul>

<h3 id="toc_11">Sintaxis concreta</h3>

<p>La sintaxis concreta es definida mediante mapeos entre la sintaxis abstracta y diferentes lenguajes concretos.
Con estas herramientas es posible parsear sentencias en algún lenguaje definido por la gramática concreta, y además linealizar desde un árbol abstracto, es decir, generar sentencias en algún lenguaje concreto.
GF permite una gramática abstracta en conjunto a varias gramáticas concretas, de esta manera posibilitando la traducción entre distintos lenguajes.</p>

<p>En la sintaxis concreta se definen:</p>

<ul>
<li><p>Categorías de linealización (lincat): Son los tipos concretos que se le asignan a cada categoría de la sintaxis abstracta. Por ejemplo, strings, records y tables.</p></li>
<li><p>Linealización (lin) de los AST, teniendo en cuenta las categorías de linealización.</p></li>
</ul>

<h4 id="toc_12">Un caso de uso pequeño</h4>

<p>Ejemplo con expresiones aritméticas en Java:</p>

<p><img src="Images/java_compiler.png" alt="java_compiler"></p>

<p>Se desea compilar una expresión aritmética en Java a código binario de JVM. Para ello existe una sintaxis abstracta común para ambas notaciones y es posible generar un AST desde la expresión en Java y  además es posible generar una expresión en JVM desde el AST.
Se logra de esta manera una traducción desde Java a JVM.</p>

<p>Sintaxis Abstracta</p>

<div><pre><code class="language-none">cat Exp ;
fun Add : Exp -&gt; Exp -&gt; Exp ;</code></pre></div>

<p>Sintaxis concreta (Java)</p>

<div><pre><code class="language-none">lincat Exp = Str ;
lin Add x y = x ++ &quot;+&quot; ++ y ;</code></pre></div>

<p>Sintaxis concreta (JVM bytecode)</p>

<div><pre><code class="language-none">lincat Exp = Str ;
lin Add x y = x ++ y ++ &quot;01100000&quot; ;</code></pre></div>

<h2 id="toc_13">Compilando lenguaje natural</h2>

<p>Para traducir entre varios lenguajes, normalmente sería necesario una traducción independiente para cada par de lenguajes.</p>

<p><img src="Images/complete_graph.png" alt="complete_graph"></p>

<p>Sin embargo, con GF la sintaxis abstracta juega el papel de &quot;Interlingua&quot;, donde solo es necesario traducir entre cada lenguaje y la Interlingua.
A modo de ejemplo, si se desea traducir desde Español a Inglés, debe traducirse primero desde Español a la Interlingua, y luego desde la Interlingua al Inglés.
El caso inverso, es decir, traducir desde Inglés a Español, funciona de la misma manera.
Se puede decir entonces que con GF es posible realizar una compilación y decompilación de la misma manera.</p>

<p><img src="Images/n_to_1_graph.png" alt="n_to_1_graph"></p>

<h3 id="toc_14">¿Cómo se logra la traducción de lenguaje natural?</h3>

<p>Sintaxis Abstracta:</p>

<div><pre><code class="language-none">fun Pred : NP -&gt; VP -&gt; S
fun Compl : V2 -&gt; NP -&gt; VP</code></pre></div>

<p><img src="Images/AST_jlm.png" alt="AST_john_loves_mary"></p>

<p>Sintaxis concreta: (SVO)</p>

<div><pre><code class="language-none">lin Pred s vo = s ++ vo
lin Compl v o = v ++ o</code></pre></div>

<p>Sintaxis concreta: (SOV)</p>

<div><pre><code class="language-none">lin Pred s vo = s ++ vo
lin Compl v o = o ++ v</code></pre></div>

<p><img src="Images/parse_tree_english.png" alt="parse_tree_english">
<img src="Images/parse_tree_latin.png" alt="parse_tree_latin"></p>

<h3 id="toc_15">Records y tables</h3>

<p>GF provee records y tables, además de strings, para definir la sintaxis concreta.</p>

<p><img src="Images/parse_tree_arabic.png" alt="parse_tree_arabic"></p>

<p>Se necesitan records para (VSO). No hay una manera de producir la linealización de la frase sin separar al predicado en dos partes (verbo y objeto), mediante un record.</p>

<p>Sintaxis concreta: (VSO)</p>

<div><pre><code class="language-none">lin Pred s vo = vo.verb ++ s ++ vo.obj
lin Compl v o = {verb = v ; obj = o}</code></pre></div>

<p>Las modificaciones de una misma palabra o frase, como género, número, persona o polaridad requieren del uso de parámetros y tables.</p>

<p>Por ejemplo, en ingles un verbo puede variar según los siguientes modificadores de tiempo y persona.</p>

<div><pre><code class="language-none">param P = Inf | Sg3P | Past | PastPart | PresPart</code></pre></div>

<p>Uso de tables:</p>

<div><pre><code class="language-none">lin Love = table {
    Inf =&gt; &quot;love&quot;;
    Sg3P =&gt; &quot;loves&quot;;
    Past | PastPart =&gt; &quot;loved&quot;;
    PresPart =&gt; &quot;loving&quot;;
}</code></pre></div>

<h3 id="toc_16">Concordancia en sintaxis concreta</h3>

<p>Es importante notar que la sintaxis abstracta permanece sin cambios.</p>

<div><pre><code class="language-none">lin She = {
    s = table {Nom =&gt; &quot;she&quot; ; Acc =&gt; &quot;her&quot; };
    a = Sg3P;
}</code></pre></div>

<div><pre><code class="language-none">lin Pred s vo = s.s ! Nom ++ vo ! s.a
lin Compl v o = table { a =&gt; v ! a ++ o.s ! acc };</code></pre></div>

<div><pre><code class="language-none">Ejemplo: she loves her</code></pre></div>

<h3 id="toc_17"> Parallel multiple context free grammars</h3>

<p>GF usa internamente <a href="http://www.sciencedirect.com/science/article/pii/030439759190374B">Parallel multiple context free grammars (PMCFG)</a>, definidas como gramáticas ligeramente sensitivas al contexto. Lo que en GF puede pensarse de manera simple como gramáticas sobre tuplas. Un hecho interesante sobre PMCFG es que, al igual que las CGF, permite parsing polinomial. </p>

<h3 id="toc_18">Abstracción multilingüe</h3>

<ul>
<li>Sintaxis abstracta

<ul>
<li>Estructura de árboles: Constituyentes y semántica.</li>
</ul></li>
<li>Sintaxis concreta

<ul>
<li>Palabras</li>
<li>Orden de palabras</li>
<li>Inflección</li>
<li>Concordancia</li>
</ul></li>
</ul>

<h2 id="toc_19">Trabajo a realizar</h2>

<p>El trabajo consiste en lograr traducir un fragmento de lenguaje natural a un lenguaje simbólico de lógica de primer orden.
Se tomó como motivación producir fórmulas lógicas para el programa <a href="https://github.com/manugunther/sat">Sat</a>.</p>

<p>Una de las ventajas de GF es que permite realizar una modularización paramétrica mediante funtores, los cuales admiten la definición de una gramática incompleta y la posibilidad de completarla con un lexicón. El objetivo es escribir una gramática incompleta de la manera más general posible, que abarque las diferentes construcciones del lenguaje formal de la lógica y luego poder instanciarla con diferentes lexicones, entre ellos, el de figuras geométricas de Sat.</p>

<h3 id="toc_20">Motivación al trabajo</h3>

<p>El primer desafío que se encuentra en el aprendizaje de la lógica está dado por la barrera lingüística impuesta por el lenguaje simbólico y artificial de la misma. Consecuentemente parece razonable comenzar un curso de lógica con la traducción de sentencias expresadas en lenguaje natural (digamos español) a su correspondiente formulación símbolica en la lógica en cuestión (proposicional, de primer orden, etc.). Las dificultades de esta traducción vienen dadas, entre otras, por la ambigüedad de la sentencia en lenguaje natural y por la puntillosidad con la que se deben construir las fórmulas lógicas.</p>

<p>El objetivo de este proyecto es extender el programa Sat con un módulo que permita a estudiantes la exploración de la traducción de lenguaje natural a fórmulas de lógica de primer orden y viceversa. De esta manera, la/el estudiante puede ir familiarizándose con la escritura formal a través de ejemplos que ella/el construye y contrastar su formalización con todas las traducciones posibles y viceversa. Esta traducción se basará teóricamente en la formalización de lenguaje natural utilizando <a href="https://books.google.com.ar/books?hl=sv&amp;lr=&amp;id=A5m13eGOcqYC&amp;oi=fnd&amp;pg=PA1&amp;dq=aarne+ranta&amp;ots=KjH2Put2Wa&amp;sig=J__Gk-RZctvQzSqJBDVXyngpY1Y&amp;redir_esc=y#v">teoría de tipos propuesta por Ranta</a> y para la implementación se utilizará el Grammatical Framework.</p>

<h1 id="toc_21"> Trabajo realizado hasta el momento</h1>

<h1 id="toc_22">Explicación de la gramática</h1>

<p>Se presenta a contuación las categorías y constructores más importantes de la gramática abstracta. Esta gramática es utiizada para poder parsear frases del español y poder traducirlas luego al lenguaje simbólico de fórmulas de primer orden. Se explica la razón de existencia de cada categoría y constructor.</p>

<h1 id="toc_23"> Categorías principales</h1>

<table>
<thead>
<tr>
<th>Categorías</th>
<th style="text-align: center">Descripción</th>
<th style="text-align: center">Ejemplos</th>
</tr>
</thead>

<tbody>
<tr>
<td>Prop</td>
<td style="text-align: center">proposición, compleja o atómica</td>
<td style="text-align: center">A es rojo y B es grande</td>
</tr>
<tr>
<td>Atom</td>
<td style="text-align: center">propisición atómica</td>
<td style="text-align: center">A es rojo</td>
</tr>
<tr>
<td>Pred1</td>
<td style="text-align: center">Predicado unario</td>
<td style="text-align: center">rojo</td>
</tr>
<tr>
<td>Pred2</td>
<td style="text-align: center">Predicado binario</td>
<td style="text-align: center">está arriba de</td>
</tr>
<tr>
<td>Ind</td>
<td style="text-align: center">término indivual</td>
<td style="text-align: center">A</td>
</tr>
<tr>
<td>Var</td>
<td style="text-align: center">variable de cuantificación</td>
<td style="text-align: center">x</td>
</tr>
<tr>
<td>Fun1</td>
<td style="text-align: center">función unaria</td>
<td style="text-align: center">cuadrado (aritmética) e.g. x^2</td>
</tr>
<tr>
<td>Fun2</td>
<td style="text-align: center">función binaria</td>
<td style="text-align: center">suma (aritmética) e.g. x+y</td>
</tr>
<tr>
<td>Conj</td>
<td style="text-align: center">conjunción</td>
<td style="text-align: center">y, o</td>
</tr>
<tr>
<td>Quant</td>
<td style="text-align: center">símbolo de cuantificación</td>
<td style="text-align: center">∀, ∃</td>
</tr>
<tr>
<td>Kind</td>
<td style="text-align: center">dominio de cuantificación</td>
<td style="text-align: center">figura </td>
</tr>
</tbody>
</table>

<h1 id="toc_24">Constructores de cada categoría</h1>

<h2 id="toc_25">Prop</h2>

<p>Prop es la categoría usada para representar cualquier proposición de primer orden válida. Se debe tener en cuenta que habrá constructores más cercanos al lenguaje simbólico y otros más cercanos al lenguaje natural.
La razón de esto es usar los constructores más cercanos al lenguaje natural para parsear español, construyendo árboles abstractos de sintaxis (AST), que luego serán transformados mediante funciones de transferencia en AST formados por los constructores más cercanos al lenguaje simbólico, para así luego linealizarlos de manera directa en fórmulas de primer orden.</p>

<h4 id="toc_26">Proposiciones simples</h4>

<ul>
<li>True : Prop</li>
<li>False : Prop</li>
</ul>

<p>Se usará True en el rango de cuantificación, por ejemplo al traducir: &quot;cada figura es roja&quot; en〈 ∀x : True : Rojo.x 〉</p>

<h4 id="toc_27">Proposiciones compuestas</h4>

<h5 id="toc_28">Proposiciones atómicas:</h5>

<ul>
<li>PAtom  : Atom  -&gt; Prop ;</li>
</ul>

<p>Proposiciones atómicas son aplicaciones de predicados 
unarios y binarios.</p>

<p>La restricción de aridad está dada en parte por SAT, ya que los predicados son únicamente unarios y binarios. Se podría generalizar la aridad, pero por el momento no se cree conveniente. Suposición: No es muy común en lenguaje natural predicados con aridad mayor.</p>

<ul>
<li><p>Ejemplo aridad 3: &quot;entre&quot;, &quot;A entre B y C&quot;
(Aridad 3 podría llegar a ser útil en SAT)</p></li>
<li><p>Ejemplos aridad &gt;3 ?</p></li>
</ul>

<p>Ejemplos:</p>

<ul>
<li>A es rojo</li>
<li>A está arriba de B</li>
<li>A es igual a B</li>
<li>A es distinto de B</li>
</ul>

<h5 id="toc_29">Negación de proposiciones:</h5>

<ul>
<li>PNeg   : Prop  -&gt; Prop ; </li>
</ul>

<p>Negación de proposiciones.</p>

<p>Ejemplo:</p>

<ul>
<li>no es el caso que A sea rojo</li>
</ul>

<p>(No es muy natural en proposiciones atómicas, ver PNegAtom)</p>

<h5 id="toc_30"> Negación atómica:</h5>

<ul>
<li>PNegAtom  : Atom -&gt; Prop ;</li>
</ul>

<p>Negación de proposiciones atómicas. Se utiliza para aceptar frases negadas más naturales como:</p>

<ul>
<li>A no es rojo</li>
<li>A no está arriba de B</li>
<li>A no es igual B</li>
</ul>

<h5 id="toc_31">Operadores binarios:</h5>

<ul>
<li>PConj  : Conj  -&gt; Prop -&gt; Prop -&gt; Prop ;</li>
<li>PImpl  : Prop  -&gt; Prop -&gt; Prop ;</li>
</ul>

<p>Ejemplos:</p>

<ul>
<li>A es rojo y B es azul</li>
<li>si A es rojo entonces B está arriba de A</li>
<li>si cada figura es roja entonces A es rojo</li>
</ul>

<h5 id="toc_32">Cuantificación:</h5>

<ul>
<li>PQuant  : Quant -&gt; Var -&gt; Prop -&gt; Prop -&gt; Prop ;</li>
</ul>

<p>Cuantificación de la forma:</p>

<p>〈 Qx : R.x : T.x 〉</p>

<p>Está ligado fuertemente al lenguaje simbólico. No hay un fragmento de lenguaje natural que parsee directamente a un AST con esta categoría.
Se genera a través de funciones de transferencia desde cuantificación in-situ. (Ver UnivIS y ExistIS)</p>

<h5 id="toc_33">Cuantificación in-situ:</h5>

<ul>
<li>UnivIS  : Var -&gt; Kind -&gt; Pred1 -&gt; Prop ;</li>
<li>ExistIS : Var -&gt; Kind -&gt; Pred1 -&gt; Prop ; </li>
</ul>

<p>Se utilizan para parsear frases cuantificadas de lenguaje natural.
Notar que hay ciertas restricciones sobre el rango y término. El rango tiene categoría Kind (ver Kind). Esta categoría juega el papel de dominio de cuantificación y el término tiene categoria Pred1.</p>

<p>¿Por qué Kind y por qué Pred1?</p>

<p>Un primer itento de justificación es que la gramática está inspirada en el trabajo <a href="http://old-darcs.grammaticalframework.org/gf-cade-2011/code/">Ranta gf-cade-2011</a>.</p>

<p>La idea de cuantificación in-situ es aceptar frases naturales de la forma: &quot;alguna [Kind] es [Pred1]&quot; ó &quot;cada [Kind] es [Pred1]&quot;.</p>

<p>Ejemplos:</p>

<ul>
<li>&quot;alguna figura es roja&quot;</li>
<li>&quot;alguna figura grande es roja&quot;</li>
<li>&quot;alguna figura grande es roja o verde&quot;</li>
</ul>

<p>Esto tiene ciertas limitaciones, como por ejemplo, no poder usar predicados binarios en el término o en el rango (Ver constructores de Kind). Sin embargo ya veremos que la aplicación parcial de predicados binarios nos permitirá aceptar frases de la forma:</p>

<ul>
<li>&quot;alguna figura está arriba de A&quot;</li>
<li>&quot;alguna figura arriba de A es roja&quot;</li>
</ul>

<p>Con este modo de representar cuantificación in-situ siguen existiendo algunas limitaciones a resolver, como:</p>

<ul>
<li>Negaciones en rango y término</li>
<li>Cuantificación anidada</li>
</ul>

<p>Ejemplos de frases que se desearían aceptar:</p>

<ul>
<li>&quot;alguna figura que no es roja está arriba de B&quot;</li>
<li>&quot;alguna figura roja está arriba de alguna figura azul&quot;</li>
<li>&quot;hay alguna figura roja arriba de alguna figura azul&quot;</li>
</ul>

<p>Pienso que estas limitaciones deberían ser resultas ya que suele ser bastante natural el uso de ambas construcciones en el lenguaje natural.</p>

<h2 id="toc_34">Atom</h2>

<p>Atom es la categoría usada para representar proposiciones atómicas.</p>

<h5 id="toc_35">Predicados</h5>

<ul>
<li><p>APred1 : Pred1 -&gt; Ind -&gt; Atom ;</p></li>
<li><p>APred2 : Pred2 -&gt; Ind -&gt; Ind -&gt; Atom ;</p></li>
</ul>

<p>Estos son los constructores de proposiciones atómicas más comunes.</p>

<p>Su uso en lenguaje natural:</p>

<ul>
<li>A es rojo (Pred1)</li>
<li>A es grande y verde (Ver ConjPred1)</li>
<li>A está arriba de B</li>
<li>A está arriba de B y C (Ver ConjInd)</li>
</ul>

<h5 id="toc_36">Distributividad de predicado binario</h5>

<ul>
<li>APred2Distr : (p : Pred2) -&gt; Distr p -&gt; [Ind] -&gt; Atom</li>
</ul>

<p>Permite la distributividad de un predicado binario en una lista de individuos.</p>

<p>Notar el uso del tipo dependiente Distr p, donde p es un predicado binario. (Leer el libro de ranta para escribir sobre tipos dependientes y su uso como Proof object)</p>

<p>La utilidad del tipo dependiente en este caso es marcar si un predicado binario es distributivo. Por ejemplo, en nuestro caso la igualdad y desigualdad son marcados como distributivos.</p>

<p>Por lo que hay un elemento para cada tipo: </p>

<ul>
<li>distr_equal : Distr Equal ;</li>
<li>distr_diff : Distr Different ;</li>
</ul>

<p>Ejemplos de uso:</p>

<ul>
<li><p>A, B y C son iguales. que traduce a: (A = B) ∧ (A = C) ∧ (B = C)</p></li>
<li><p>A y B son distintos. que traduce a : ¬(A = B)</p></li>
</ul>

<h5 id="toc_37">Aplicación Reflexiva de predicado binario</h5>

<ul>
<li>APredRefl : Pred2 -&gt; Ind -&gt; Atom ;</li>
</ul>

<p>Aplicación de un predicado binario con el mismo individuo.
Es un caso particular de APred2. Permite aceptar frases como:</p>

<ul>
<li>A es igual a sí</li>
<li>A está arriba de sí</li>
</ul>

<h2 id="toc_38">Pred1 y Pred2</h2>

<p>Los predicados representan las características de los individuos de nuestro universo.
Uno puede querer preguntarse en SAT, por ejemplo, si una figura particular es un cuadrado, o si es rojo.
Luego, los predicados son un fragmento dependiente de la signatura, que el usuario de la aplicación debería definir. 
En SAT tiene sentido definir los siguientes predicados:</p>

<h4 id="toc_39">Constructores básicos</h4>

<h5 id="toc_40">Pred1</h5>

<h6 id="toc_41"> Color de figura</h6>

<ul>
<li>Rojo, Azul, Verde : Pred1 ;</li>
</ul>

<h6 id="toc_42">Tamaño de figura</h6>

<ul>
<li>Chico, Mediano, Grande: Pred1 ;</li>
</ul>

<h6 id="toc_43">Forma de figura</h6>

<ul>
<li>Triangulo, Cuadrado, Circulo : Pred1 ;</li>
</ul>

<p>Ejemplos:</p>

<ul>
<li>A es rojo</li>
<li>A es chico</li>
<li>A es cuadrado</li>
</ul>

<h5 id="toc_44"> Pred2</h5>

<h6 id="toc_45"> Igualdad y diferencia</h6>

<ul>
<li>Equal : Pred2 ;</li>
<li>Different : Pred2 ;</li>
</ul>

<p>Se define la diferencia como un predicado aparte para permitir frases:</p>

<ul>
<li>A no es igual a B (Negación de Equal)</li>
<li>A es diferente de B (Different)</li>
</ul>

<h5 id="toc_46">Posición vertical</h5>

<ul>
<li>Arriba, Abajo : Pred2 ;</li>
</ul>

<h5 id="toc_47">Posición horizontal</h5>

<ul>
<li>Izquierda, Derecha : Pred2 ;</li>
</ul>

<p>Ejemplos:</p>

<ul>
<li>A está arriba de B</li>
<li>A está a la izquierda de B</li>
</ul>

<h4 id="toc_48">Conjunción de predicados y aplicación parcial</h4>

<ul>
<li>ConjPred1 : Conj -&gt; [Pred1] -&gt; Pred1 ;</li>
</ul>

<p>Conjunción de predicados unarios permite usar frases como: &quot;A es rojo y grande&quot;</p>

<ul>
<li>PartPred : Pred2 -&gt; Ind -&gt; Pred1 ;</li>
</ul>

<p>Aplicación parcial, principalmente útil en cuantificación in-situ, ya que la restricción de rango y término requieren predicados unarios.</p>

<p>Se pueden aceptar frases como:</p>

<ul>
<li>cada figura arriba de B es roja (aplicación parcial en rango)</li>
<li>cada figura roja está arriba de B (aplicación parcial en término)</li>
</ul>

<h2 id="toc_49">Ind</h2>

<p>Son los elementos individuales del universo. Tanto los predicados como la cuantificación operan sobre ellos.</p>

<h5 id="toc_50">Constantes y Variables</h5>

<ul>
<li>IVar   : Var -&gt; Ind ;</li>
</ul>

<p>Por el momento no hay una diferencia entre variables (útiles para cuantificar) y elementos constantes. (Esto es algo a mejorar)</p>

<p>SAT hace una diferencia entre constantes (mayúsculas) y variables (comienzan con una letra minúscula).</p>

<h4 id="toc_51">Conjunción de individuos</h4>

<ul>
<li>ConjInd : Conj -&gt; [Ind] -&gt; Ind ;</li>
</ul>

<p>Es útil para poder aplicar un predicado a varios individuos. (Ver por ejemplo APred1 y notar que toma un único individuo).</p>

<p>Ejemplo:</p>

<ul>
<li>A, B y C son rojos</li>
<li>A está arriba de B y C</li>
</ul>

<h2 id="toc_52">Var</h2>

<p>Variables de cuantificación. </p>

<ul>
<li>VString : String -&gt; Var ;</li>
</ul>

<p>El único constructor es VString, no presta importancia a minúsculas, ni mayúsculas.</p>

<h2 id="toc_53">Fun1 y Fun2</h2>

<p>Si bien en SAT no hay funciones, están incluidas en la gramática.
La utilidad que podrían tener es construir individuos resultado de funciones, usando constructores como:</p>

<ul>
<li>IFun1  : Fun1 -&gt; Ind -&gt; Ind ;</li>
<li>IFun2  : Fun2 -&gt; Ind -&gt; Ind -&gt; Ind ;</li>
</ul>

<p>Ejemplos en una aplicación de aritmética:</p>

<ul>
<li>El cuadrado de x (Fun1)</li>
<li>La suma de a y b (Fun2)</li>
</ul>

<h2 id="toc_54">Conj</h2>

<p>Conjunciones polimórficas. Se utilizan para conectar proposiciones, individuos y predicados.</p>

<ul>
<li>CAnd, COr : Conj ;</li>
</ul>

<p>Ejemplos:</p>

<ul>
<li>A es rojo o B es azul</li>
<li>A es grande y verde</li>
<li>A y B son cuadrados</li>
</ul>

<h2 id="toc_55"> Quant</h2>

<p>Define los símbolos de cuantificación de primer orden.</p>

<ul>
<li>ForAll : Quant ; (∀)</li>
<li>Exists : Quant ; (∃)</li>
</ul>

<h2 id="toc_56">Kind</h2>

<p>Categoría utilizada para definir los dominios de cuantificación in-situ. Está más ligado al lenguaje natural que al lenguaje simbólico.</p>

<p>Kind también es dependiente de la signatura. En SAT Kind tiene un solo constructor básico que es Figura.</p>

<ul>
<li>Figura : Kind ;</li>
</ul>

<p>Existe además un modificador de Kind para tener dominios más restringidos.</p>

<ul>
<li>ModKind : Kind -&gt; Pred1 -&gt; Kind ;</li>
</ul>

<p>Esto permite frases como:</p>

<ul>
<li>cada figura roja es grande</li>
<li>cada figura roja y grande es cuadrada</li>
</ul>

<h1 id="toc_57">Funciones de transferencia</h1>

<p>(Explicar las funciones de transferencia)</p>

<h2 id="toc_58">Bibliografía</h2>

<ol>
<li><a href="http://www.grammaticalframework.org/">GF webpage</a></li>
<li><a href="http://www.grammaticalframework.org/gf-book/">Libro: Grammatical Framework: Programming with Multilingual Grammars</a></li>
<li><a href="http://www.grammaticalframework.org/doc/gf-lrec-2010.pdf">GF tutorial</a></li>
<li><a href="https://www.youtube.com/watch?v=x1LFbDQhbso">Google Tech Talk, Aarne Ranta</a></li>
<li><a href="https://www.semanticscholar.org/paper/Translating-between-Language-and-Logic-What-Is-Eas-Ranta/581281bb6292814ce285dc1de82a9785fdac2b5d">Paper: Translating between Language and Logic: What Is Easy and What Is Difficult, Aarne Ranta, CADE2011</a></li>
<li><a href="http://www.grammaticalframework.org/%7Eaarne/cade-talk.pdf">Slides: Translating between Language and Logic: What Is Easy and What Is Difficult, Aarne Ranta, CADE2011</a></li>
</ol>




</body>

</html>

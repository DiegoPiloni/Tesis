Fecha: 19/07/17

* Empiezo a escribir en este archivo los cambios y nuevas 
funcionalidades del proyecto.


* Reordené (y a mi criterio mejoré) la forma de tratar con 
igualdad/desigualdad de invididuos.
Ahora la igualdad (Equal en Logic.gf) y la diferencia (Different en Logic.gf), 
tratada como un caso adicional, son predicados binarios (Pred2).
La diferencia es tratada aparte para poder escribir frases como "A es distinto de B".
Sin esta separación la única forma de expresar esto sería mediante la frase: 
"A no es igual a B" (como negación de sentencias atómicas).

[

Miguel: no es tan fácil linealizar ¬A=B como "A es diferente de B" porque
los parámetros refieren a cosas linealizadas.

Diego tira la idea de usar tipos dependientes para ver si facilita.

La solución es utilizar un constructor nuevo que permita parsear más
oraciones pero nos lo quitamos de encima mediante una función de
transferencia. La pregunta es si podemos hacer una función inversa
que nos de tanto "¬(A = B)" como "A≠B".

¿Una función de transferencia puede devolver una lista?

Experimento: parsear "A es distinto de B" y devolverlo de vuelta a
español pasando por Symb nos da un montón de resultados entre ellos
el original.
]


* Implementé la aplicación parcial de predicados binarios. 
    (PartPred : Pred2 -> Ind -> Pred1, en Logic.gf)
Esta nueva funcionalidad requirió, en primer medida, modificar 
las categorías en la sintaxis concreta (lincat) de Pred1 y Pred2.
La forma en que implementé esto es usando records y parámetros, 
que serán los que definirán el tipo de predicado y hacielndo casos 
(comando "case") en Logic(Spa | Sym).gf para manipular los regristros 
de manera adecuada.

Los parámetros usados son:
  - param Pred2Type = Equality | Inequality | Position ;
  - param Pred1Type = Original | Equality1 | Inequality1 | Position1 ;
  ( No está muy elegante esto, ya voy a ver si hay una forma mejor de hacerlo)

y en el caso de la sintaxis del lenguaje simbólico, los tipos de registros:
  - Pred1 = { t : Pred1Type ; symb : Str ; ind : Str } ;
  Donde se guarda el tipo del predicado (original o proveniente de una aplicación parcial),
  el símbolo del predicado y el individuo que se propaga en caso de ser una aplicación parcial.
  (Notar que en el caso que Pred1Type sea Original, ind no tiene utilidad. 
  Buscar mejor forma de resolver esto!)

[

- Una primera mejora es utilizar un constructor para Pred1Type y no repetir
cada constructor de Pred2Type.

- ¿Podemos generalizar ambos tipos y definir Pred cuyo primer campo indica
si es binario o unario? ¿Cómo lidiamos con aplicación parcial? 

- Para evitar tener que inventar un string (vacío) para cuando Pred1Type
es original podemos utilizar tipos dependientes

def
  indPred1 : Pred1Type -> Set 
  indPred1 Original = ⊥
  indPred1 (PA _)   = String


] 

  - Pred2 = { t : Pred2Type ; s : Str } ;
(Para más detalle ver Categories(Spa | Sym).gf y Logic(Spa | Sym).gf)

La aplicación parcial permite frases como las siguientes:
> Aplicación parcial en el término de cuantificación:
    - "Cada figura roja está a la izquierda de B"
    Donde "a la izquierda de B" se parsea como un predicado unario, creado a partir de la aplicación 
    parcial del Pred2 Izquierda con el Ind "B".
    De la misma manera otras frases como:
    - "cada figura roja es igual a B"
    - "cada figura roja es diferente de B"
> Aplicación parcial en el rango de cuantificación:
    - "cada figura arriba de B es roja"
    (Hasta el momento es la única manera de escribir esto. creo que estaría bueno también poder escribir
    frases como "cada figura que está arriba de B es roja", es decir, agregando "que está").
    De la misma manera otras frases como:
    - "alguna figura arriba de B es grande"
    - "cada figura diferente de B es roja"
    - "cada figura distinta de B está arriba de B" (aplicación parcial en rango y término)

Notar que ahora frases como: "A está arriba de B", pueden ser interpretadas como la aplicación normal
de un predicado binario, o como la aplicación del predicado unario generado a partir de la aplicación parcial ("arriba de b").


* Función de transferencia PropPreds ampliada, para conjunción 
de individuos en Pred2 y en aplicación parcial.

Sobre Pred2:
Hago algunas suposiciones que creo correctas: (Espero su devolución sobre esto)

La frase:
    "A no está arriba de B y C"
se traduce a:
    ¬(arriba.A.B ∧ arriba.A.C)
Mientras que:
    "A y B no están arriba de C"
se traduce a:
    (¬arriba.A.C ∧ ¬arriba.B.C)

(Ver PropPreds en Logic.gf para ver todos los casos.)

[ Miguel le pasa la gramática a Diego ]

* Agregué APredRefl : Pred2 -> Ind -> Atom, para escribir frases donde los individuos aplicados
al predicado binario sean el mismo.
Se aceptan frases como:
    "A es igual a sí" (Estaría bueno agregar "igual a sí mismo" ?)
    "A no está arriba de sí"

Notar que APredRefl genera dos interpretaciones posibles:
    "A es igual a sí"
traduce a:
    "(A = A)"
    "(A = sí)"
La solución a esto debería ir de la mano con que en SAT solo mayúsculas son nombres de constantes.


* Pendiente: Distribuir predicado binario a una lista de individuos.
Frases que agregaría esto:
    "A, B y C son iguales"
    "A, B y C son distintos"
Pensamiento:
    Predicados "posicionales", como estar arriba de, no deberían poder ser
    "distribuídos".

[

Diego está usando tipos dependientes para indicar si se puede
distribuir o no.

]



Fecha: 24/07/17

* Empecé a implementar la distribución de predicados binarios a lista de individuos.
Uso tipos dependientes para poder seleccionar los predicados que distribuyen y los que no.
Ver categoría (Distr Pred2) y funciones (distr_equal, distr_diff).

Nota: El parser no completa el arbol. (Ver bien distintos casos (gf/examples/chapter6/(DShopping.gf|Classes.gf)) 
de parseo con tipos dependientes) 

Ejemplo:
p -lang=Spa "A y B son iguales"
genera:
PAtom (APred2Distr Equal ?2 (BaseInd (IVar (VString "A")) (IVar (VString "B"))))

Es posible completarlo pasando el AST al comando gt (generate_tree).
Ejemplo:
p -lang=Spa "A y B son iguales" | gt -lang=Spa
genera:
PAtom (APred2Distr Equal distr_equal (BaseInd (IVar (VString "A")) (IVar (VString "B"))))

Aun no está resuelto como generar en GF las posibles combinaciones de pares de individuos,
para listas de largo mayor o igual a 3.

Ejemplo:
parsear la frase:
 p -lang=Spa "A , B y C son iguales" | gt -lang=Spa
genera:
PAtom (APred2Distr Equal distr_equal (ConsInd (IVar (VString "A")) (BaseInd (IVar (VString "B")) (IVar (VString "C")))))

La función de transferencia, para producir un AST que linealice a lenguaje simbólico debería generar:
(A = B) ∧ (A = C) ∧ (B = C)


* Agregué una función PConjs : Conj -> [Prop] -> Prop, (Ver Logic.gf) para parsear listas de proposiciones.
Ejemplo de uso:
p -tr -lang=Spa "A es rojo , B es verde y C es azul" | gt -lang=Spa | pt -transfer=PropList | l -bind -lang=Sym
parsea:
PConjs CAnd (ConsProp (PAtom (APred1 Rojo (IVar (VString "A")))) (BaseProp (PAtom (APred1 Verde (IVar (VString "B")))) (PAtom (APred1 Azul (IVar (VString "C"))))))
linealiza:
(Rojo.A ∧ (Verde.B ∧ Azul.C))


* Mejoré el tipo Pred1Type, usando constructores, al estilo Haskell.

TO DO:
======

1) Terminar distribución de predicados binarios
2) Implementar Negación de Kinds
3) Modularizar funciones de transferencia
4) Entender un poco mejor tipos dependientes, ver si se pueden usar como dijo Miguel 
(Ver comentarios en 19/07).

02/08/17

copia de mail que mandé:

Buenas, cuento un (no tan) poco lo que estuve haciendo:

1)
Pregunté en la lista de mail de GF sobre distribución de predicados en una lista de individuos. Más que nada mi intención era saber si existía alguna manera de lograr la generación de todas las combinaciones de 2 elementos de la lista mediante una función de transferencia en GF, y al parecer la respuesta es "No". Sobre esto se me ocurren dos opciones: 
Dejar GF y usar Haskell. (Mi principal inconveniente con Haskell es que pierdo la "interactividad" que provee la app de GF, con cosas como, parsing incremental, posibilidad de rastrear los AST, etc).
Seguir con GF, teniendo en mente que hay cosas que no voy a poder hacer, y luego las voy a tener que hacer en Haskell.

2)
Investigué y logré abrir un servidor sencillo donde uno puede cargar su gramática y hacer parsing incremental. 
Tiene una interfaz bastante simple y bonita. Todo  el código es del paquete de GF. 
Ranta llama a la interfaz Minibar, un ejemplo, con gramáticas de prueba está en:

http://cloud.grammaticalframework.org/minibar/minibar.html

El problema: La traducción es directa (sin la posibilidad de usar funciones de transferencia), y hasta ahora no encontré
la forma de modificar esto, estuve ojeando un poco la API de Javascript.
Sin embargo puede ser de gran ayuda ver este código si en algún momento implemento algo web propio.

3)
Lo que hasta ahora más tiempo me viene llevando y sin mucho progreso:
En un principio el título sería "Negación de Kind".

Como repaso:
Kind está en este momento pensado como "Dominio de cuantificación" y hay una constructor base, que en SAT es Figura, y modificadores, que son predicados unarios (Pred1) que son (lingüísticamente) adjetivos que modifican a figura.

Luego uno puede lograr parsear frases como:

toda figura roja ... (en realidad, cada figura roja ..., otra de las cosas que tengo que hacer)
toda figura roja y grande ...
toda figura roja y abajo de A ... (con aplicación parcial)

y la idea inicial era poder agregar en los dominios de cuantificación un poco de negación y poder aceptar frases como:
Toda figura que no es roja ...
Toda figura roja y que no es grande ...

El problema principal, para mí, es que no es tan fácil de generalizar esto.

La primera nota importante que puedo tomar, es que no solo es útil lo que estoy haciendo para dominios de cuantificación, sino que también se aplica en conjunción de predicados en sentencias sin cuantificadores.

Algunos ejemplos:

A es rojo pero no es grande
A no es rojo y grande
A no es rojo ni grande
A es rojo, chico, pero no es cuadrado

y casos así hay un montón, y hasta el momento no los estoy consiguiendo atrapar con alguna idea general, o no tan general, pero que al menos sea aceptable.

Lo más general que se me ocurre: 
Mezclar adjetivos "positivos" con adjetivos "negados". 
por ejemplo:
* A es rojo, [es] grande, y no es cuadrado. / A es rojo, [es] grande pero no es cuadrado.
* A es rojo, no es grande y es cuadrado.


Una idea que por ahí podría simplificar un poco las cosas, es solo permitir "positivos" por un lado y "negativos" por otro.
Algo como:
A es Adj1, Adj2, ... y AdjN pero no es Adj(N+1), Adj(N+2), ... ni Adj(N+M).

Es algo arbitrario, pero por ahí algo más claro para interpretar y escribir.

--

De código no hubo mucho avance, principalmente porque estoy un poco trabado con esto.

Perdón por lo extenso, y si por ahí hay cosas que no quedan muy claras, avisen.

Voy a seguir trabajando en estos días con estas ideas, más que nada 3)

Estaría bueno si pueden leerlas antes de la próxima reunión. Yo este viernes estoy en Córdoba, así que si pueden juntarse, me vendría bárbaro.

Saludos, y que anden bien !